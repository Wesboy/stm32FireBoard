#include "bsp_esp8266.h"
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

struct STRUCT_USARTx_Fram strEsp8266_Fram_Record = {0};

/**
  * @brief  ESP8266?????????
  * @param  ??
  * @retval ??
  */
void ESP8266_Init(void)
{

	macESP8266_RST_HIGH_LEVEL();

	macESP8266_CH_DISABLE();
}

/*
 * ????????ESP8266_Rst
 * ????  ??????WF-ESP8266???
 * ????  ????
 * ????  : ??
 * ????  ???? ESP8266_AT_Test ????
 */
void ESP8266_Rst(void)
{
#if 0
	 ESP8266_Cmd ( "AT+RST", "OK", "ready", 2500 );

#else
	macESP8266_RST_LOW_LEVEL();
	HAL_Delay(500);
	macESP8266_RST_HIGH_LEVEL();
#endif
}

/*
 * ????????ESP8266_Cmd
 * ????  ????WF-ESP8266??ú€??AT???
 * ????  ??cmd????????????
 *         reply1??reply2?????????????NULL????????????????????????
 *         waittime?????????????
 * ????  : 1?????????
 *         0??????????
 * ????  ??????????
 */

extern UART_HandleTypeDef huart3;

bool ESP8266_Cmd(char *cmd, char *reply1, char *reply2, uint32_t waittime)
{
	strEsp8266_Fram_Record.InfBit.FramLength = 0; //??????????????????

	macESP8266_Usart("%s\r\n", cmd);

	//macPC_Usart("%s\r\n", cmd);
	if ((reply1 == 0) && (reply2 == 0)) //?????????????
		return true;

	HAL_Delay(waittime); //???

	strEsp8266_Fram_Record.Data_RX_BUF[strEsp8266_Fram_Record.InfBit.FramLength] = '\0';

	macPC_Usart("%s", strEsp8266_Fram_Record.Data_RX_BUF);

	if ((reply1 != 0) && (reply2 != 0))
		return ((bool)strstr(strEsp8266_Fram_Record.Data_RX_BUF, reply1) ||
				(bool)strstr(strEsp8266_Fram_Record.Data_RX_BUF, reply2));

	else if (reply1 != 0)
		return ((bool)strstr(strEsp8266_Fram_Record.Data_RX_BUF, reply1));

	else
		return ((bool)strstr(strEsp8266_Fram_Record.Data_RX_BUF, reply2));
}

/*
 * ????????ESP8266_AT_Test
 * ????  ????WF-ESP8266??????AT????????
 * ????  ????
 * ????  : ??
 * ????  ??????????
 */
//void ESP8266_AT_Test ( void )
//{
//	macESP8266_RST_HIGH_LEVEL();
//
//	Delay_ms ( 1000 );
//
//	while ( ! ESP8266_Cmd ( "AT", "OK", NULL, 500 ) ) ESP8266_Rst ();

//}
void ESP8266_AT_Test(void)
{
	char count = 0;

	macESP8266_RST_HIGH_LEVEL();
	HAL_Delay(1000);
	while (count < 10)
	{
		if (ESP8266_Cmd("AT", "OK", NULL, 500))
			return;
		ESP8266_Rst();
		++count;
	}
}

/*
 * ????????ESP8266_Net_Mode_Choose
 * ????  ?????WF-ESP8266?????????
 * ????  ??enumMode????????
 * ????  : 1???????
 *         0????????
 * ????  ??????????
 */
bool ESP8266_Net_Mode_Choose(ENUM_Net_ModeTypeDef enumMode)
{
	switch (enumMode)
	{
	case STA:
		return ESP8266_Cmd("AT+CWMODE=1", "OK", "no change", 2500);

	case AP:
		return ESP8266_Cmd("AT+CWMODE=2", "OK", "no change", 2500);

	case STA_AP:
		return ESP8266_Cmd("AT+CWMODE=3", "OK", "no change", 2500);

	default:
		return false;
	}
}

/*
 * ????????ESP8266_JoinAP
 * ????  ??WF-ESP8266?????????WiFi
 * ????  ??pSSID??WiFi?????????
 *       ??pPassWord??WiFi?????????
 * ????  : 1????????
 *         0?????????
 * ????  ??????????
 */
bool ESP8266_JoinAP(char *pSSID, char *pPassWord)
{
	char cCmd[120];

	sprintf(cCmd, "AT+CWJAP=\"%s\",\"%s\"", pSSID, pPassWord);

	return ESP8266_Cmd(cCmd, "OK", NULL, 5000);
}

/*
 * ????????ESP8266_BuildAP
 * ????  ??WF-ESP8266??ø’??WiFi???
 * ????  ??pSSID??WiFi?????????
 *       ??pPassWord??WiFi?????????
 *       ??enunPsdMode??WiFi???????????????
 * ????  : 1?????????
 *         0?????????
 * ????  ??????????
 */
bool ESP8266_BuildAP(char *pSSID, char *pPassWord, ENUM_AP_PsdMode_TypeDef enunPsdMode)
{
	char cCmd[120];

	sprintf(cCmd, "AT+CWSAP=\"%s\",\"%s\",1,%d", pSSID, pPassWord, enunPsdMode);

	return ESP8266_Cmd(cCmd, "OK", 0, 1000);
}

/*
 * ????????ESP8266_Enable_MultipleId
 * ????  ??WF-ESP8266?????????????
 * ????  ??enumEnUnvarnishTx??????????????
 * ????  : 1?????¨®??
 *         0?????????
 * ????  ??????????
 */
bool ESP8266_Enable_MultipleId(FunctionalState enumEnUnvarnishTx)
{
	char cStr[20];

	sprintf(cStr, "AT+CIPMUX=%d", (enumEnUnvarnishTx ? 1 : 0));

	return ESP8266_Cmd(cStr, "OK", 0, 500);
}

/*
 * ????????ESP8266_Link_Server
 * ????  ??WF-ESP8266???????????????
 * ????  ??enumE??????§¿??
 *       ??ip????????IP?????
 *       ??ComNum????????????????
 *       ??id????????????????ID
 * ????  : 1????????
 *         0?????????
 * ????  ??????????
 */
bool ESP8266_Link_Server(ENUM_NetPro_TypeDef enumE, char *ip, char *ComNum, ENUM_ID_NO_TypeDef id)
{
	char cStr[100] = {0}, cCmd[120];

	switch (enumE)
	{
	case enumTCP:
		sprintf(cStr, "\"%s\",\"%s\",%s", "TCP", ip, ComNum);
		break;

	case enumUDP:
		sprintf(cStr, "\"%s\",\"%s\",%s", "UDP", ip, ComNum);
		break;

	default:
		break;
	}

	if (id < 5)
		sprintf(cCmd, "AT+CIPSTART=%d,%s", id, cStr);

	else
		sprintf(cCmd, "AT+CIPSTART=%s", cStr);

	return ESP8266_Cmd(cCmd, "OK", "ALREAY CONNECT", 4000);
}

/*
 * ????????ESP8266_StartOrShutServer
 * ????  ??WF-ESP8266????????????????
 * ????  ??enumMode??????/???
 *       ??pPortNum?????????????????
 *       ??pTimeOver???????????????????????¦Ë????
 * ????  : 1?????????
 *         0?????????
 * ????  ??????????
 */
bool ESP8266_StartOrShutServer(FunctionalState enumMode, char *pPortNum, char *pTimeOver)
{
	char cCmd1[120], cCmd2[120];

	if (enumMode)
	{
		sprintf(cCmd1, "AT+CIPSERVER=%d,%s", 1, pPortNum);

		sprintf(cCmd2, "AT+CIPSTO=%s", pTimeOver);

		return (ESP8266_Cmd(cCmd1, "OK", 0, 500) &&
				ESP8266_Cmd(cCmd2, "OK", 0, 500));
	}

	else
	{
		sprintf(cCmd1, "AT+CIPSERVER=%d,%s", 0, pPortNum);

		return ESP8266_Cmd(cCmd1, "OK", 0, 500);
	}
}

/*
 * ????????ESP8266_Get_LinkStatus
 * ????  ????? WF-ESP8266 ???????????????????????
 * ????  ????
 * ????  : 2?????ip
 *         3??????????
 *         3????????
 *         0??????????
 * ????  ??????????
 */
uint8_t ESP8266_Get_LinkStatus(void)
{
	if (ESP8266_Cmd("AT+CIPSTATUS", "OK", 0, 500))
	{
		if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "STATUS:2\r\n"))
			return 2;

		else if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "STATUS:3\r\n"))
			return 3;

		else if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "STATUS:4\r\n"))
			return 4;
	}

	return 0;
}

/*
 * ????????ESP8266_Get_IdLinkStatus
 * ????  ????? WF-ESP8266 ?????Id??????????????????????
 * ????  ????
 * ????  : ????Id??????????????5¦Ë???§¹¦Ë???????Id5~0???¦Ë????1????Id?????????????????0????Id¦Ä????????
 * ????  ??????????
 */
uint8_t ESP8266_Get_IdLinkStatus(void)
{
	uint8_t ucIdLinkStatus = 0x00;

	if (ESP8266_Cmd("AT+CIPSTATUS", "OK", 0, 500))
	{
		if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "+CIPSTATUS:0,"))
			ucIdLinkStatus |= 0x01;
		else
			ucIdLinkStatus &= ~0x01;

		if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "+CIPSTATUS:1,"))
			ucIdLinkStatus |= 0x02;
		else
			ucIdLinkStatus &= ~0x02;

		if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "+CIPSTATUS:2,"))
			ucIdLinkStatus |= 0x04;
		else
			ucIdLinkStatus &= ~0x04;

		if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "+CIPSTATUS:3,"))
			ucIdLinkStatus |= 0x08;
		else
			ucIdLinkStatus &= ~0x08;

		if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "+CIPSTATUS:4,"))
			ucIdLinkStatus |= 0x10;
		else
			ucIdLinkStatus &= ~0x10;
	}

	return ucIdLinkStatus;
}

/*
 * ????????ESP8266_Inquire_ApIp
 * ????  ????? F-ESP8266 ?? AP IP
 * ????  ??pApIp????? AP IP ???????????
 *         ucArrayLength????? AP IP ??????????
 * ????  : 0????????
 *         1????????
 * ????  ??????????
 */
uint8_t ESP8266_Inquire_ApIp(char *pApIp, uint8_t ucArrayLength)
{
	char uc;

	char *pCh;

	ESP8266_Cmd("AT+CIFSR", "OK", 0, 500);

	pCh = strstr(strEsp8266_Fram_Record.Data_RX_BUF, "APIP,\"");

	if (pCh)
		pCh += 6;

	else
		return 0;

	for (uc = 0; uc < ucArrayLength; uc++)
	{
		pApIp[uc] = *(pCh + uc);

		if (pApIp[uc] == '\"')
		{
			pApIp[uc] = '\0';
			break;
		}
	}

	return 1;
}

/*
 * ????????ESP8266_UnvarnishSend
 * ????  ??????WF-ESP8266?????????????
 * ????  ????
 * ????  : 1?????¨®??
 *         0?????????
 * ????  ??????????
 */
bool ESP8266_UnvarnishSend(void)
{
	if (!ESP8266_Cmd("AT+CIPMODE=1", "OK", 0, 500))
		return false;

	return ESP8266_Cmd("AT+CIPSEND", "OK", ">", 500);
}

/*
 * ????????ESP8266_ExitUnvarnishSend
 * ????  ??????WF-ESP8266???????????
 * ????  ????
 * ????  : ??
 * ????  ??????????
 */
void ESP8266_ExitUnvarnishSend(void)
{
	HAL_Delay(1000);

	macESP8266_Usart("+++");

	HAL_Delay(500);
}

/*
 * ????????ESP8266_SendString
 * ????  ??WF-ESP8266??ú€???????
 * ????  ??enumEnUnvarnishTx?????????????????????
 *       ??pStr?????????????
 *       ??ulStrLength????????????????????
 *       ??ucId?????ID??????????
 * ????  : 1????????
 *         0?????????
 * ????  ??????????
 */
bool ESP8266_SendString(FunctionalState enumEnUnvarnishTx, char *pStr, uint32_t ulStrLength, ENUM_ID_NO_TypeDef ucId)
{
	char cStr[20];
	bool bRet = false;

	if (enumEnUnvarnishTx)
	{
		macESP8266_Usart("%s", pStr);

		bRet = true;
	}

	else
	{
		if (ucId < 5)
			sprintf(cStr, "AT+CIPSEND=%d,%d", ucId, ulStrLength + 2);

		else
			sprintf(cStr, "AT+CIPSEND=%d", ulStrLength + 2);

		ESP8266_Cmd(cStr, "> ", 0, 1000);

		bRet = ESP8266_Cmd(pStr, "SEND OK", 0, 1000);
	}

	return bRet;
}

/*
 * ????????ESP8266_ReceiveString
 * ????  ??WF-ESP8266???????????
 * ????  ??enumEnUnvarnishTx?????????????????????
 * ????  : ????????????????
 * ????  ??????????
 */
char *ESP8266_ReceiveString(FunctionalState enumEnUnvarnishTx)
{
	char *pRecStr = 0;

	strEsp8266_Fram_Record.InfBit.FramLength = 0;
	strEsp8266_Fram_Record.InfBit.FramFinishFlag = 0;

	while (!strEsp8266_Fram_Record.InfBit.FramFinishFlag)
		;
	strEsp8266_Fram_Record.Data_RX_BUF[strEsp8266_Fram_Record.InfBit.FramLength] = '\0';

	if (enumEnUnvarnishTx)
		pRecStr = strEsp8266_Fram_Record.Data_RX_BUF;

	else
	{
		if (strstr(strEsp8266_Fram_Record.Data_RX_BUF, "+IPD"))
			pRecStr = strEsp8266_Fram_Record.Data_RX_BUF;
	}

	return pRecStr;
}
